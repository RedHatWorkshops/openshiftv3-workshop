[[create-an-app-using-docker-build]]
### Create an App using Docker build


In this exercise we will learn how to create an application from a
Dockerfile. OpenShift takes Dockerfile as an input and generates your
application docker image for you.

*Step 1: Create a project or use an existing project*

If you want to, you can create a new project based on what you have
learned in the previous lab. Since we already have a project we will use
it. Run the following command to make sure.

IMPORTANT: Please replace *userxx* with the username assigned to you in
the commands below.

----
$ oc project mycliproject-userxx
----

*Step 2: Create an application that uses Dockerfile*

This time we will use a project that has a Dockerfile in a source code
repository. We will use a simple project on github
(https://github.com/RedHatWorkshops/s2i-workshop). "dockerfile/httpd" folder from this github
project is built starting with httpd image pulled from `access.redhat.com/containers`  as the base image which is
described in Dockerfile. Look at the Dockerfile for this project. It
starts off with `registry.access.redhat.com/rhscl/httpd-24-rhel7` image. It copies the
an index.html file to `/var/www/html`  file and exposes port `8080`.
Its a simple welcome message.  

NOTE: When OpenShift finds a Dockerfile in the source, it uses
this Dockerfile as the basis to create a docker image for your
application. This strategy is called *Docker Build* strategy on
OpenShift. We'll see more about it when we look at the build
configuration a couple of steps down the line. Once OpenShift builds the
application's docker image, it stores that in a local docker registry.
Later it uses this image to deploy an application that runs in a pod.

Now let's create an application using this approach. We will run
`oc new-app` command by supplying the git uri as the parameter.

----
oc new-app https://github.com/RedHatWorkshops/s2i-workshop  --context-dir=dockerfile/httpd --name=myhttpdapp
--> Found Docker image f584e39 (2 weeks old) from registry.access.redhat.com for "registry.access.redhat.com/rhscl/httpd-24-rhel7"

    Apache httpd 2.4
    ----------------
    Apache httpd 2.4 available as container, is a powerful, efficient, and extensible web server. Apache supports a variety of features, many implemented as compiled modules which extend the core functionality. These can range from server-side programming language support to authentication schemes. Virtual hosting allows one Apache installation to serve many different Web sites.

    Tags: builder, httpd, httpd24

    * An image stream tag will be created as "httpd-24-rhel7:latest" that will track the source image
    * A Docker build using source code from https://github.com/RedHatWorkshops/s2i-workshop will be created
      * The resulting image will be pushed to image stream tag "myhttpdapp:latest"
      * Every time "httpd-24-rhel7:latest" changes a new build will be triggered
    * This image will be deployed in deployment config "myhttpdapp"
    * Port 8080/tcp will be load balanced by service "myhttpdapp"
      * Other containers can access this service through the hostname "myhttpdapp"

--> Creating resources ...
    imagestream.image.openshift.io "httpd-24-rhel7" created
    imagestream.image.openshift.io "myhttpdapp" created
    buildconfig.build.openshift.io "myhttpdapp" created
    deploymentconfig.apps.openshift.io "myhttpdapp" created
    service "myhttpdapp" created
--> Success
    Build scheduled, use 'oc logs -f bc/myhttpdapp' to track its progress.
    Application is not exposed. You can expose services to the outside world by executing one or more of the commands below:
     'oc expose svc/myhttpdapp'
    Run 'oc status' to view your app.

----

You'll notice that OpenShift created a few things at this point. You
will find a `buildconfig`, `deploymentconfig`, `service` and `imagestreams` in
the above list. The application is not running yet. It needs to be built
and deployed. Within a minute or so, you will see that OpenShift starts
the build.

*Step 3: Build*

In the meanwhile lets have a look at the `buildconfig` by running the
command shown below.

----
$ oc get bc myhttpdapp -o yaml
apiVersion: build.openshift.io/v1
kind: BuildConfig
metadata:
  annotations:
    openshift.io/generated-by: OpenShiftNewApp
  creationTimestamp: 2018-11-12T21:27:05Z
  labels:
    app: myhttpdapp
  name: myhttpdapp
  namespace: mycliproject-user1
  resourceVersion: "39682"
  selfLink: /apis/build.openshift.io/v1/namespaces/mycliproject-user1/buildconfigs/myhttpdapp
  uid: b41dbd12-e6c1-11e8-b0ef-02cc00155950
spec:
  failedBuildsHistoryLimit: 5
  nodeSelector: null
  output:
    to:
      kind: ImageStreamTag
      name: myhttpdapp:latest
  postCommit: {}
  resources: {}
  runPolicy: Serial
  source:
    contextDir: dockerfile/httpd
    git:
      uri: https://github.com/RedHatWorkshops/s2i-workshop
    type: Git
  strategy:
    dockerStrategy:
      from:
        kind: ImageStreamTag
        name: httpd-24-rhel7:latest
    type: Docker
  successfulBuildsHistoryLimit: 5
  triggers:
  - github:
      secret: 2hF5G9LlJyHHi2NnnFip
    type: GitHub
  - generic:
      secret: IdpQ9jp7jEi_qXVgAcVX
    type: Generic
  - type: ConfigChange
  - imageChange:
      lastTriggeredImageID: registry.access.redhat.com/rhscl/httpd-24-rhel7@sha256:9b1f52e0405b30c4275e88a1109de42c2de0c98d63c9c46ab16ac76965aecdbc
    type: ImageChange
status:
  lastVersion: 1

----

Note the name of the `buildconfig` in metadata is set to "myhttpdapp", the git
uri pointing to the value you gave while creating the application. Also
note the Strategy.type set to "Docker". This indicates that the build
will use the instructions in this Dockerfile to do the docker build.

Build starts in a minute or so. You can view the list of builds using
`oc get builds` command. You can also start the build using
`oc start-build time` where "time" is the name we noticed in the
`buildconfig`.

----
$ oc get builds
NAME           TYPE      FROM          STATUS     STARTED          DURATION
myhttpdapp-1   Docker    Git@ab60a03   Complete   11 minutes ago   9s
----

Note the name of the build that is running i.e. `myhttpdapp-1`. We will use that
name to look at the build logs. Run the command as shown below to look
at the build logs. This will run for a few mins. At the end you will
notice that the docker image is successfully created and it will start
pushing this to OpenShift internal docker registry.

----
$  oc logs build/myhttpdapp-1
Cloning "https://github.com/RedHatWorkshops/s2i-workshop" ...
	Commit:	ab60a037cf993448e86c4e49eb0cfbcf27ae160c (Update Dockerfile)
	Author:	Robert Sandoval <rsandova@redhat.com>
	Date:	Mon Nov 12 15:23:24 2018 -0600
Replaced Dockerfile FROM image registry.access.redhat.com/rhscl/httpd-24-rhel7
Step 1/6 : FROM registry.access.redhat.com/rhscl/httpd-24-rhel7@sha256:9b1f52e0405b30c4275e88a1109de42c2de0c98d63c9c46ab16ac76965aecdbc
 ---> f584e3997022
Step 2/6 : ADD ./index.html /var/www/html
 ---> Using cache
 ---> e5012cb76cce
Step 3/6 : USER 1001
 ---> Using cache
 ---> 06fae3c039d1
Step 4/6 : EXPOSE 8080
 ---> Using cache
 ---> 3661e9b0cbff
Step 5/6 : ENV "OPENSHIFT_BUILD_NAME" "myhttpdapp-1" "OPENSHIFT_BUILD_NAMESPACE" "mycliproject-user1" "OPENSHIFT_BUILD_SOURCE" "https://github.com/RedHatWorkshops/s2i-workshop" "OPENSHIFT_BUILD_COMMIT" "ab60a037cf993448e86c4e49eb0cfbcf27ae160c"
 ---> Running in ae792a365931
 ---> be7fab75c573
Removing intermediate container ae792a365931
Step 6/6 : LABEL "io.openshift.build.commit.author" "Robert Sandoval \u003crsandova@redhat.com\u003e" "io.openshift.build.commit.date" "Mon Nov 12 15:23:24 2018 -0600" "io.openshift.build.commit.id" "ab60a037cf993448e86c4e49eb0cfbcf27ae160c" "io.openshift.build.commit.message" "Update Dockerfile" "io.openshift.build.commit.ref" "master" "io.openshift.build.name" "myhttpdapp-1" "io.openshift.build.namespace" "mycliproject-user1" "io.openshift.build.source-context-dir" "dockerfile/httpd" "io.openshift.build.source-location" "https://github.com/RedHatWorkshops/s2i-workshop"
 ---> Running in b490c1b88bc1
 ---> 0b83c56e707a
Removing intermediate container b490c1b88bc1
Successfully built 0b83c56e707a

Pushing image docker-registry.default.svc:5000/mycliproject-user1/myhttpdapp:latest ...
Push successful
----

In the above log note how the image is pushed to the local docker
registry. The registry is running at `docker-registry.default.svc` at port `5000`.

*Step 4: Deployment*

Once the image is pushed to the docker registry, OpenShift will trigger
a deploy process. Let us also quickly look at the deployment
configuration by running the following command. Note `dc` represents
`deploymentconfig`.

----
$ oc get dc myhttpdapp -o yaml
apiVersion: apps.openshift.io/v1
kind: DeploymentConfig
metadata:
  annotations:
    openshift.io/generated-by: OpenShiftNewApp
  creationTimestamp: 2018-11-12T21:27:06Z
  generation: 2
  labels:
    app: myhttpdapp
  name: myhttpdapp
  namespace: mycliproject-user1
  resourceVersion: "39785"
  selfLink: /apis/apps.openshift.io/v1/namespaces/mycliproject-user1/deploymentconfigs/myhttpdapp
  uid: b426420b-e6c1-11e8-b0ef-02cc00155950
spec:
  replicas: 1
  revisionHistoryLimit: 10
  selector:
    app: myhttpdapp
    deploymentconfig: myhttpdapp
  strategy:
    activeDeadlineSeconds: 21600
    resources: {}
    rollingParams:
      intervalSeconds: 1
      maxSurge: 25%
      maxUnavailable: 25%
      timeoutSeconds: 600
      updatePeriodSeconds: 1
    type: Rolling
  template:
    metadata:
      annotations:
        openshift.io/generated-by: OpenShiftNewApp
      creationTimestamp: null
      labels:
        app: myhttpdapp
        deploymentconfig: myhttpdapp
    spec:
      containers:
      - image: docker-registry.default.svc:5000/mycliproject-user1/myhttpdapp@sha256:fc7eb1c2e420802dc7c0520cd418a564acd9303e2795eba8f83a0ecccbcdaa72
        imagePullPolicy: Always
        name: myhttpdapp
        ports:
        - containerPort: 8080
          protocol: TCP
        resources: {}
        terminationMessagePath: /dev/termination-log
        terminationMessagePolicy: File
      dnsPolicy: ClusterFirst
      restartPolicy: Always
      schedulerName: default-scheduler
      securityContext: {}
      terminationGracePeriodSeconds: 30
  test: false
  triggers:
  - type: ConfigChange
  - imageChangeParams:
      automatic: true
      containerNames:
      - myhttpdapp
      from:
        kind: ImageStreamTag
        name: myhttpdapp:latest
        namespace: mycliproject-user1
      lastTriggeredImage: docker-registry.default.svc:5000/mycliproject-user1/myhttpdapp@sha256:fc7eb1c2e420802dc7c0520cd418a564acd9303e2795eba8f83a0ecccbcdaa72
    type: ImageChange
status:
  availableReplicas: 1
  conditions:
  - lastTransitionTime: 2018-11-12T21:27:22Z
    lastUpdateTime: 2018-11-12T21:27:22Z
    message: Deployment config has minimum availability.
    status: "True"
    type: Available
  - lastTransitionTime: 2018-11-12T21:27:19Z
    lastUpdateTime: 2018-11-12T21:27:23Z
    message: replication controller "myhttpdapp-1" successfully rolled out
    reason: NewReplicationControllerAvailable
    status: "True"
    type: Progressing
  details:
    causes:
    - type: ConfigChange
    message: config change
  latestVersion: 1
  observedGeneration: 2
  readyReplicas: 1
  replicas: 1
  unavailableReplicas: 0
  updatedReplicas: 1

----

Note where the image is picked from. It shows that the deployment picks
the image from the local registry (same service name and port as in
`buildconfig`) and the image tag is same as what we built earlier. This
means the deployment step deploys the application image what was built
earlier during the build step.

If you get the list of pods, you'll notice that the application gets
deployed quickly and starts running in its own pod.

----
$ oc get pods
NAME                 READY     STATUS      RESTARTS   AGE
myhttpdapp-1-76mrw   1/1       Running     0          15m
myhttpdapp-1-build   0/1       Completed   0          15m
----

*Step 5: Adding route*

This step is very much the same as what we did in the previous exercise.
We will check the service and add a route to expose that service.

----
$ oc get services

NAME         TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE
myhttpdapp   ClusterIP   172.30.5.159   <none>        8080/TCP   15m
----

Here we expose the service as a route.

----
$ oc expose service myhttpdapp

route.route.openshift.io/myhttpdapp exposed
----

And then we check the route exposed.

----
$ oc get routes

NAME         HOST/PORT                                                                  PATH      SERVICES     PORT       TERMINATION   WILDCARD
myhttpdapp   myhttpdapp-mycliproject-user1.apps.sanantonio-bfa3.openshiftworkshop.com             myhttpdapp   8080-tcp                 None
----

NOTE: Unlike in the previous lab, this time we did not use --hostname
parameter while exposing the service to create a route. OpenShift
automatically assigned the project name extension to the route name.

*Step 6: Run the application*

Now run the application by using the route you provided in the previous
step. You can use either curl or your browser. The application displays
time.

NOTE: If you don't provide time.php extension, it displays apache's
default index page.

----
$ curl myhttpdapp-mycliproject-userxx.{{APPS_ADDRESS}}

----

Congratulations!! In this exercise you have learnt how to create, build
and deploy an application using OpenShift's "Docker Build strategy".
